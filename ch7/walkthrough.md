- T类型的值不拥有\*T类型值的方法，编译器自动为T类型取地址&，使用\*T的方法只是语法糖。对于interface来说，要**严格保证该类型拥有interface要求的方法**。

  - 以io.Reader为例，如果*T拥有，那么在给接口赋值时

    ```go
    r := &T{.....}
    ```

  - 如果T拥有

    ```go
    r := T{.....}
    ```

- interface{}，空接口，对于具体实现它的类型没有任何要求，故而可以赋给它任意一个值

  - 依靠类型断言来获取利用存在该接口中的值

- 编译期断言，确定某个类型实现了某个接口的全部方法：

  ```go
  var _ io.Writer = (*bytes.Buffer)(nil)
  ```

  - 我们不需要用到分配的变量，所以直接用nil强转即可；
  - 我们不使用定义的变量，所以用_略去

- 类似于Write之类的方法，会隐式修改成员变量，所以一般io.Writer这样的，实现为**结构体指针**（方法绑定到指针上/receiver设定为指针）

- interface{}可比较

  - 相同条件：类型相同，该类型可比较，比较相等
  - 可能panic：类型相同但不可比较

- 接口值的nil（概念上）包含两部分

  - 接口值nil
  - 接口类型nil

  ```go
  var i interface{}
  var s *bytes.Buffer
  i = s
  ```

  这时，i != nil。这里的nil，是接口的nil，类型和值均为空。而i的类型已经不为空

- 类型断言

  - x.(T)，T是类型就检查是否是这个类型；T是接口就检查是否满足相应方法。不匹配会panic
  - a, ok := x.(T)，第二个变量指示是否匹配，不会panic
  - 类型开关 switch x.(type)，然后case列举匹配选型类型

- 类型断言可以看作go对于多态的支持，运行时（存疑，但从逻辑上来讲，这个事情必须在运行时做）按需检查接口是否满足某一 类型/接口要求 ，然后可以用确保合法的类型/接口来调用独有的方法